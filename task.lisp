(in-package :pcall)

(defclass task ()
  ((thunk :initarg :thunk :reader task-thunk)
   (error :initform nil :accessor task-error)
   (values :accessor task-values)
   (lock :initform (make-lock) :reader task-lock)
   (status :initform :free :accessor task-status)))

(defun handle-task (thread-condition task)
  (with-lock-held ((task-lock task))
    (unless (eq (task-status task) :free)
      (return-from handle-task))
    (setf (task-status task) thread-condition))
  (handler-case
      (setf (task-values task) (multiple-value-list (funcall (task-thunk task))))
    (error (e) (setf (task-error task) e)))
  (with-lock-held ((task-lock task))
    (setf (task-status task) :done)
    (condition-notify thread-condition)))

(defun join (task)
  (with-lock-held ((task-lock task))
    (cond ((eq (task-status task) :done) nil)
          ((eq (task-status task) :free) (setf (task-status task) :mine))
          (t (condition-wait (task-status task) (task-lock task)))))
  (cond ((eq (task-status task) :mine) (funcall (task-thunk task)))
        ((task-error task) (error (task-error task)))
        (t (values-list (task-values task)))))
